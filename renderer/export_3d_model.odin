package renderer

import app "../app"
import mb "../mandelbrot"
import "core:fmt"
import "core:os"
import "core:strings"
import "core:time"

// Export 3D Mandelbrot visualization as OBJ model
// Resolution can be reduced to create smaller files
export_3d_model_obj :: proc(
	r: ^Renderer,
	state: ^app.App_State,
	width, height: int,
	filepath: string,
) -> bool {
	fmt.printfln("Exporting 3D model to %s...", filepath)
	fmt.printfln("Resolution: %dx%d (%d columns)", width, height, width * height)

	start_time := time.now()

	// Generate instance data (same as rendering, but possibly at different resolution)
	instances := make([]Column_Instance, width * height)
	defer delete(instances)

	// We need pixel data at the export resolution
	temp_pixels := make([]u32, width * height)
	defer delete(temp_pixels)

	// Compute Mandelbrot at export resolution
	temp_state := state^
	temp_state.pixels = temp_pixels

	compute_start := time.now()

	// Note: For 3D model export, we always use CPU computation
	if state.use_gpu {
		fmt.println("Note: Using CPU computation for 3D model export")
	}

	mb.Compute(&temp_state, width, height)

	compute_duration := time.diff(compute_start, time.now())
	fmt.printfln("Computation: %.2f ms", time.duration_milliseconds(compute_duration))

	// Build instances from pixel data
	instance_idx := 0
	for py in 0 ..< height {
		for px in 0 ..< width {
			pixel := temp_pixels[py * width + px]

			// Extract color
			r_val := f32((pixel >> 16) & 0xFF) / 255.0
			g_val := f32((pixel >> 8) & 0xFF) / 255.0
			b_val := f32(pixel & 0xFF) / 255.0

			// Calculate height from brightness (same as renderer_3d.odin)
			brightness := (r_val + g_val + b_val) / 3.0

			// Invert height for plateau effect
			height_value := 1.0 - brightness

			// Position in grid (centered at origin)
			x_pos := f32(px) - f32(width) / 2.0
			y_pos := f32(py) - f32(height) / 2.0

			instances[instance_idx] = Column_Instance {
				position = {x_pos, y_pos},
				height   = height_value,
				color    = {r_val, g_val, b_val},
			}
			instance_idx += 1
		}
	}

	// Generate OBJ file
	gen_start := time.now()
	success := write_obj_file(filepath, instances, state.height_scale_3d, state.column_width_3d)
	gen_duration := time.diff(gen_start, time.now())

	if success {
		total_duration := time.diff(start_time, time.now())
		fmt.printfln("OBJ generation: %.2f ms", time.duration_milliseconds(gen_duration))
		fmt.printfln("Total export time: %.2f ms", time.duration_milliseconds(total_duration))
		fmt.println("✓ 3D model export completed successfully!")
	} else {
		fmt.eprintln("✗ 3D model export failed!")
	}

	return success
}

// Write OBJ file from column instances
write_obj_file :: proc(
	filepath: string,
	instances: []Column_Instance,
	height_scale: f32,
	column_width: f32,
) -> bool {
	builder := strings.builder_make()
	defer strings.builder_destroy(&builder)

	// Write header
	strings.write_string(&builder, "# Mandelbrot 3D Model Export\n")
	strings.write_string(&builder, "# Generated by Mandelbrodin\n")
	strings.write_string(&builder, fmt.tprintf("# Columns: %d\n", len(instances)))
	strings.write_string(&builder, "\n")

	vertex_offset := 0 // Current vertex index (1-based in OBJ)

	// For each column instance, generate cube geometry
	for instance, col_idx in instances {
		// Skip very short columns to reduce file size
		if instance.height < 0.01 {
			continue
		}

		// Calculate actual column parameters
		scaled_height := instance.height * height_scale

		// Cube vertices (8 corners)
		// Base vertices (bottom of column)
		x := instance.position.x
		y := instance.position.y
		z_bottom := -scaled_height * 0.5 // Columns grow downward from top (z=0)

		hw := column_width * 0.5 // Half width

		// Bottom 4 vertices
		v0 := [3]f32{x - hw, y - hw, z_bottom}
		v1 := [3]f32{x + hw, y - hw, z_bottom}
		v2 := [3]f32{x + hw, y + hw, z_bottom}
		v3 := [3]f32{x - hw, y + hw, z_bottom}

		// Top 4 vertices (at z=0, the plateau level)
		v4 := [3]f32{x - hw, y - hw, 0.0}
		v5 := [3]f32{x + hw, y - hw, 0.0}
		v6 := [3]f32{x + hw, y + hw, 0.0}
		v7 := [3]f32{x - hw, y + hw, 0.0}

		// Write vertices with colors
		vertices := [8][3]f32{v0, v1, v2, v3, v4, v5, v6, v7}
		for v in vertices {
			strings.write_string(
				&builder,
				fmt.tprintf("v %.6f %.6f %.6f %.3f %.3f %.3f\n",
					v.x, v.y, v.z,
					instance.color.r, instance.color.g, instance.color.b),
			)
		}

		// Write normals for each face
		// (6 faces, each has its own normal)
		normals := [6][3]f32 {
			{0, 0, -1}, // Bottom
			{0, 0, 1}, // Top
			{0, -1, 0}, // Front
			{0, 1, 0}, // Back
			{-1, 0, 0}, // Left
			{1, 0, 0}, // Right
		}

		for n in normals {
			strings.write_string(&builder, fmt.tprintf("vn %.3f %.3f %.3f\n", n.x, n.y, n.z))
		}

		// Write faces (2 triangles per face, 12 triangles total)
		// OBJ uses 1-based indexing
		base := vertex_offset + 1

		// Bottom face (v0, v1, v2, v3)
		strings.write_string(&builder, fmt.tprintf("f %d//%d %d//%d %d//%d\n", base + 0, base + 0, base + 1, base + 1, base + 2, base + 2))
		strings.write_string(&builder, fmt.tprintf("f %d//%d %d//%d %d//%d\n", base + 0, base + 0, base + 2, base + 2, base + 3, base + 3))

		// Top face (v4, v5, v6, v7)
		strings.write_string(&builder, fmt.tprintf("f %d//%d %d//%d %d//%d\n", base + 4, base + 4, base + 6, base + 6, base + 5, base + 5))
		strings.write_string(&builder, fmt.tprintf("f %d//%d %d//%d %d//%d\n", base + 4, base + 4, base + 7, base + 7, base + 6, base + 6))

		// Front face (v0, v1, v5, v4)
		strings.write_string(&builder, fmt.tprintf("f %d//%d %d//%d %d//%d\n", base + 0, base + 0, base + 1, base + 1, base + 5, base + 5))
		strings.write_string(&builder, fmt.tprintf("f %d//%d %d//%d %d//%d\n", base + 0, base + 0, base + 5, base + 5, base + 4, base + 4))

		// Back face (v2, v3, v7, v6)
		strings.write_string(&builder, fmt.tprintf("f %d//%d %d//%d %d//%d\n", base + 2, base + 2, base + 7, base + 7, base + 3, base + 3))
		strings.write_string(&builder, fmt.tprintf("f %d//%d %d//%d %d//%d\n", base + 2, base + 2, base + 6, base + 6, base + 7, base + 7))

		// Left face (v3, v0, v4, v7)
		strings.write_string(&builder, fmt.tprintf("f %d//%d %d//%d %d//%d\n", base + 3, base + 3, base + 0, base + 0, base + 4, base + 4))
		strings.write_string(&builder, fmt.tprintf("f %d//%d %d//%d %d//%d\n", base + 3, base + 3, base + 4, base + 4, base + 7, base + 7))

		// Right face (v1, v2, v6, v5)
		strings.write_string(&builder, fmt.tprintf("f %d//%d %d//%d %d//%d\n", base + 1, base + 1, base + 2, base + 2, base + 6, base + 6))
		strings.write_string(&builder, fmt.tprintf("f %d//%d %d//%d %d//%d\n", base + 1, base + 1, base + 6, base + 6, base + 5, base + 5))

		vertex_offset += 8
	}

	// Write to file
	content := strings.to_string(builder)
	success := os.write_entire_file(filepath, transmute([]u8)content)

	if !success {
		fmt.eprintln("Failed to write OBJ file:", filepath)
		return false
	}

	// Print file stats
	file_size := len(content)
	fmt.printfln("File size: %.2f MB", f64(file_size) / (1024.0 * 1024.0))

	return true
}
